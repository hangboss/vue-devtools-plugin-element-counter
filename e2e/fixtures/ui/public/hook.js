/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/@vue-devtools/app-backend-core/lib/hook.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/@vue-devtools/app-backend-core/lib/hook.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// this script is injected into every page.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.installHook = void 0;\n/**\n * Install the hook on window, which is an event emitter.\n * Note because Chrome content scripts cannot directly modify the window object,\n * we are evaling this function by inserting a script tag. That's why we have\n * to inline the whole event emitter implementation here.\n *\n * @param {Window|global} target\n */\nfunction installHook(target, isIframe = false) {\n    const devtoolsVersion = '6.0';\n    let listeners = {};\n    function injectIframeHook(iframe) {\n        if (iframe.__vdevtools__injected) {\n            return;\n        }\n        try {\n            iframe.__vdevtools__injected = true;\n            const inject = () => {\n                try {\n                    iframe.contentWindow.__VUE_DEVTOOLS_IFRAME__ = iframe;\n                    const script = iframe.contentDocument.createElement('script');\n                    script.textContent = `;(${installHook.toString()})(window, true)`;\n                    iframe.contentDocument.documentElement.appendChild(script);\n                    script.parentNode.removeChild(script);\n                }\n                catch (e) {\n                    // Ignore\n                }\n            };\n            inject();\n            iframe.addEventListener('load', () => inject());\n        }\n        catch (e) {\n            // Ignore\n        }\n    }\n    let iframeChecks = 0;\n    function injectToIframes() {\n        if (typeof window === 'undefined') {\n            return;\n        }\n        const iframes = document.querySelectorAll('iframe:not([data-vue-devtools-ignore])');\n        for (const iframe of iframes) {\n            injectIframeHook(iframe);\n        }\n    }\n    injectToIframes();\n    const iframeTimer = setInterval(() => {\n        injectToIframes();\n        iframeChecks++;\n        if (iframeChecks >= 5) {\n            clearInterval(iframeTimer);\n        }\n    }, 1000);\n    if (Object.prototype.hasOwnProperty.call(target, '__VUE_DEVTOOLS_GLOBAL_HOOK__')) {\n        if (target.__VUE_DEVTOOLS_GLOBAL_HOOK__.devtoolsVersion !== devtoolsVersion) {\n            console.error(`Another version of Vue Devtools seems to be installed. Please enable only one version at a time.`);\n        }\n        return;\n    }\n    let hook;\n    if (isIframe) {\n        const sendToParent = (cb) => {\n            try {\n                const hook = window.parent.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n                if (hook) {\n                    return cb(hook);\n                }\n                else {\n                    console.warn('[Vue Devtools] No hook in parent window');\n                }\n            }\n            catch (e) {\n                console.warn('[Vue Devtools] Failed to send message to parent window', e);\n            }\n        };\n        hook = {\n            devtoolsVersion,\n            // eslint-disable-next-line accessor-pairs\n            set Vue(value) {\n                sendToParent((hook) => {\n                    hook.Vue = value;\n                });\n            },\n            // eslint-disable-next-line accessor-pairs\n            set enabled(value) {\n                sendToParent((hook) => {\n                    hook.enabled = value;\n                });\n            },\n            on(event, fn) {\n                sendToParent(hook => hook.on(event, fn));\n            },\n            once(event, fn) {\n                sendToParent(hook => hook.once(event, fn));\n            },\n            off(event, fn) {\n                sendToParent(hook => hook.off(event, fn));\n            },\n            emit(event, ...args) {\n                sendToParent(hook => hook.emit(event, ...args));\n            },\n            cleanupBuffer(matchArg) {\n                var _a;\n                return (_a = sendToParent(hook => hook.cleanupBuffer(matchArg))) !== null && _a !== void 0 ? _a : false;\n            },\n        };\n    }\n    else {\n        hook = {\n            devtoolsVersion,\n            Vue: null,\n            enabled: undefined,\n            _buffer: [],\n            _bufferMap: new Map(),\n            _bufferToRemove: new Map(),\n            store: null,\n            initialState: null,\n            storeModules: null,\n            flushStoreModules: null,\n            apps: [],\n            _replayBuffer(event) {\n                const buffer = this._buffer;\n                this._buffer = [];\n                this._bufferMap.clear();\n                this._bufferToRemove.clear();\n                for (let i = 0, l = buffer.length; i < l; i++) {\n                    const allArgs = buffer[i].slice(1);\n                    allArgs[0] === event\n                        // eslint-disable-next-line prefer-spread\n                        ? this.emit.apply(this, allArgs)\n                        : this._buffer.push(buffer[i]);\n                }\n            },\n            on(event, fn) {\n                const $event = `$${event}`;\n                if (listeners[$event]) {\n                    listeners[$event].push(fn);\n                }\n                else {\n                    listeners[$event] = [fn];\n                    this._replayBuffer(event);\n                }\n            },\n            once(event, fn) {\n                const on = (...args) => {\n                    this.off(event, on);\n                    return fn.apply(this, args);\n                };\n                this.on(event, on);\n            },\n            off(event, fn) {\n                event = `$${event}`;\n                if (!arguments.length) {\n                    listeners = {};\n                }\n                else {\n                    const cbs = listeners[event];\n                    if (cbs) {\n                        if (!fn) {\n                            listeners[event] = null;\n                        }\n                        else {\n                            for (let i = 0, l = cbs.length; i < l; i++) {\n                                const cb = cbs[i];\n                                if (cb === fn || cb.fn === fn) {\n                                    cbs.splice(i, 1);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            },\n            emit(event, ...args) {\n                const $event = `$${event}`;\n                let cbs = listeners[$event];\n                if (cbs) {\n                    cbs = cbs.slice();\n                    for (let i = 0, l = cbs.length; i < l; i++) {\n                        try {\n                            const result = cbs[i].apply(this, args);\n                            if (typeof (result === null || result === void 0 ? void 0 : result.catch) === 'function') {\n                                result.catch((e) => {\n                                    console.error(`[Hook] Error in async event handler for ${event} with args:`, args);\n                                    console.error(e);\n                                });\n                            }\n                        }\n                        catch (e) {\n                            console.error(`[Hook] Error in event handler for ${event} with args:`, args);\n                            console.error(e);\n                        }\n                    }\n                }\n                else {\n                    const buffered = [Date.now(), event, ...args];\n                    this._buffer.push(buffered);\n                    for (let i = 2; i < args.length; i++) {\n                        if (typeof args[i] === 'object' && args[i]) {\n                            // Save by component instance  (3rd, 4th or 5th arg)\n                            this._bufferMap.set(args[i], buffered);\n                            break;\n                        }\n                    }\n                }\n            },\n            /**\n             * Remove buffered events with any argument that is equal to the given value.\n             * @param matchArg Given value to match.\n             */\n            cleanupBuffer(matchArg) {\n                const inBuffer = this._bufferMap.has(matchArg);\n                if (inBuffer) {\n                    // Mark event for removal\n                    this._bufferToRemove.set(this._bufferMap.get(matchArg), true);\n                }\n                return inBuffer;\n            },\n            _cleanupBuffer() {\n                const now = Date.now();\n                // Clear buffer events that are older than 10 seconds or marked for removal\n                this._buffer = this._buffer.filter(args => !this._bufferToRemove.has(args) && now - args[0] < 10000);\n                this._bufferToRemove.clear();\n                this._bufferMap.clear();\n            },\n        };\n        setInterval(() => {\n            hook._cleanupBuffer();\n        }, 10000);\n        hook.once('init', (Vue) => {\n            hook.Vue = Vue;\n            if (Vue) {\n                Vue.prototype.$inspect = function () {\n                    const fn = target.__VUE_DEVTOOLS_INSPECT__;\n                    fn && fn(this);\n                };\n            }\n        });\n        hook.on('app:init', (app, version, types) => {\n            const appRecord = {\n                app,\n                version,\n                types,\n            };\n            hook.apps.push(appRecord);\n            hook.emit('app:add', appRecord);\n        });\n        hook.once('vuex:init', (store) => {\n            hook.store = store;\n            hook.initialState = clone(store.state);\n            const origReplaceState = store.replaceState.bind(store);\n            store.replaceState = (state) => {\n                hook.initialState = clone(state);\n                origReplaceState(state);\n            };\n            // Dynamic modules\n            let origRegister, origUnregister;\n            if (store.registerModule) {\n                hook.storeModules = [];\n                origRegister = store.registerModule.bind(store);\n                store.registerModule = (path, module, options) => {\n                    if (typeof path === 'string') {\n                        path = [path];\n                    }\n                    hook.storeModules.push({ path, module, options });\n                    origRegister(path, module, options);\n                    if (true) {\n                        // eslint-disable-next-line no-console\n                        console.log('early register module', path, module, options);\n                    }\n                };\n                origUnregister = store.unregisterModule.bind(store);\n                store.unregisterModule = (path) => {\n                    if (typeof path === 'string') {\n                        path = [path];\n                    }\n                    const key = path.join('/');\n                    const index = hook.storeModules.findIndex(m => m.path.join('/') === key);\n                    if (index !== -1) {\n                        hook.storeModules.splice(index, 1);\n                    }\n                    origUnregister(path);\n                    if (true) {\n                        // eslint-disable-next-line no-console\n                        console.log('early unregister module', path);\n                    }\n                };\n            }\n            hook.flushStoreModules = () => {\n                store.replaceState = origReplaceState;\n                if (store.registerModule) {\n                    store.registerModule = origRegister;\n                    store.unregisterModule = origUnregister;\n                }\n                return hook.storeModules || [];\n            };\n        });\n    }\n    Object.defineProperty(target, '__VUE_DEVTOOLS_GLOBAL_HOOK__', {\n        get() {\n            return hook;\n        },\n    });\n    // Handle apps initialized before hook injection\n    if (target.__VUE_DEVTOOLS_HOOK_REPLAY__) {\n        try {\n            target.__VUE_DEVTOOLS_HOOK_REPLAY__.forEach(cb => cb(hook));\n            target.__VUE_DEVTOOLS_HOOK_REPLAY__ = [];\n        }\n        catch (e) {\n            console.error('[vue-devtools] Error during hook replay', e);\n        }\n    }\n    // Clone deep utility for cloning initial state of the store\n    // Forked from https://github.com/planttheidea/fast-copy\n    // Last update: 2019-10-30\n    // ⚠️ Don't forget to update `./hook.js`\n    // utils\n    const { toString: toStringFunction } = Function.prototype;\n    const { create, defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, getPrototypeOf, } = Object;\n    const { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n    /**\n     * @enum\n     *\n     * @const {object} SUPPORTS\n     *\n     * @property {boolean} SYMBOL_PROPERTIES are symbol properties supported\n     * @property {boolean} WEAKSET is WeakSet supported\n     */\n    const SUPPORTS = {\n        SYMBOL_PROPERTIES: typeof getOwnPropertySymbols === 'function',\n        WEAKSET: typeof WeakSet === 'function',\n    };\n    /**\n     * @function createCache\n     *\n     * @description\n     * get a new cache object to prevent circular references\n     *\n     * @returns the new cache object\n     */\n    const createCache = () => {\n        if (SUPPORTS.WEAKSET) {\n            return new WeakSet();\n        }\n        const object = create({\n            add: value => object._values.push(value),\n            has: value => !!~object._values.indexOf(value),\n        });\n        object._values = [];\n        return object;\n    };\n    /**\n     * @function getCleanClone\n     *\n     * @description\n     * get an empty version of the object with the same prototype it has\n     *\n     * @param object the object to build a clean clone from\n     * @param realm the realm the object resides in\n     * @returns the empty cloned object\n     */\n    const getCleanClone = (object, realm) => {\n        if (!object.constructor) {\n            return create(null);\n        }\n        // eslint-disable-next-line no-proto, no-restricted-properties\n        const prototype = object.__proto__ || getPrototypeOf(object);\n        if (object.constructor === realm.Object) {\n            return prototype === realm.Object.prototype ? {} : create(prototype);\n        }\n        if (~toStringFunction.call(object.constructor).indexOf('[native code]')) {\n            try {\n                return new object.constructor();\n            }\n            catch (e) {\n                // Error\n            }\n        }\n        return create(prototype);\n    };\n    /**\n     * @function getObjectCloneLoose\n     *\n     * @description\n     * get a copy of the object based on loose rules, meaning all enumerable keys\n     * and symbols are copied, but property descriptors are not considered\n     *\n     * @param object the object to clone\n     * @param realm the realm the object resides in\n     * @param handleCopy the function that handles copying the object\n     * @returns the copied object\n     */\n    const getObjectCloneLoose = (object, realm, handleCopy, cache) => {\n        const clone = getCleanClone(object, realm);\n        for (const key in object) {\n            if (hasOwnProperty.call(object, key)) {\n                clone[key] = handleCopy(object[key], cache);\n            }\n        }\n        if (SUPPORTS.SYMBOL_PROPERTIES) {\n            const symbols = getOwnPropertySymbols(object);\n            if (symbols.length) {\n                for (let index = 0, symbol; index < symbols.length; index++) {\n                    symbol = symbols[index];\n                    if (propertyIsEnumerable.call(object, symbol)) {\n                        clone[symbol] = handleCopy(object[symbol], cache);\n                    }\n                }\n            }\n        }\n        return clone;\n    };\n    /**\n     * @function getObjectCloneStrict\n     *\n     * @description\n     * get a copy of the object based on strict rules, meaning all keys and symbols\n     * are copied based on the original property descriptors\n     *\n     * @param object the object to clone\n     * @param realm the realm the object resides in\n     * @param handleCopy the function that handles copying the object\n     * @returns the copied object\n     */\n    const getObjectCloneStrict = (object, realm, handleCopy, cache) => {\n        const clone = getCleanClone(object, realm);\n        const properties = SUPPORTS.SYMBOL_PROPERTIES\n            ? [].concat(getOwnPropertyNames(object), getOwnPropertySymbols(object))\n            : getOwnPropertyNames(object);\n        if (properties.length) {\n            for (let index = 0, property, descriptor; index < properties.length; index++) {\n                property = properties[index];\n                if (property !== 'callee' && property !== 'caller') {\n                    descriptor = getOwnPropertyDescriptor(object, property);\n                    descriptor.value = handleCopy(object[property], cache);\n                    defineProperty(clone, property, descriptor);\n                }\n            }\n        }\n        return clone;\n    };\n    /**\n     * @function getRegExpFlags\n     *\n     * @description\n     * get the flags to apply to the copied regexp\n     *\n     * @param regExp the regexp to get the flags of\n     * @returns the flags for the regexp\n     */\n    const getRegExpFlags = (regExp) => {\n        let flags = '';\n        if (regExp.global) {\n            flags += 'g';\n        }\n        if (regExp.ignoreCase) {\n            flags += 'i';\n        }\n        if (regExp.multiline) {\n            flags += 'm';\n        }\n        if (regExp.unicode) {\n            flags += 'u';\n        }\n        if (regExp.sticky) {\n            flags += 'y';\n        }\n        return flags;\n    };\n    const { isArray } = Array;\n    const GLOBAL_THIS = (() => {\n        // eslint-disable-next-line no-restricted-globals\n        if (typeof self !== 'undefined') {\n            // eslint-disable-next-line no-restricted-globals\n            return self;\n        }\n        if (typeof window !== 'undefined') {\n            return window;\n        }\n        if (typeof globalThis !== 'undefined') {\n            return globalThis;\n        }\n        if (console && console.error) {\n            console.error('Unable to locate global object, returning \"this\".');\n        }\n    })();\n    /**\n     * @function clone\n     *\n     * @description\n     * copy an object deeply as much as possible\n     *\n     * If `strict` is applied, then all properties (including non-enumerable ones)\n     * are copied with their original property descriptors on both objects and arrays.\n     *\n     * The object is compared to the global constructors in the `realm` provided,\n     * and the native constructor is always used to ensure that extensions of native\n     * objects (allows in ES2015+) are maintained.\n     *\n     * @param object the object to copy\n     * @param [options] the options for copying with\n     * @param [options.isStrict] should the copy be strict\n     * @param [options.realm] the realm (this) object the object is copied from\n     * @returns the copied object\n     */\n    function clone(object, options = null) {\n        // manually coalesced instead of default parameters for performance\n        const isStrict = !!(options && options.isStrict);\n        const realm = (options && options.realm) || GLOBAL_THIS;\n        const getObjectClone = isStrict\n            ? getObjectCloneStrict\n            : getObjectCloneLoose;\n        /**\n         * @function handleCopy\n         *\n         * @description\n         * copy the object recursively based on its type\n         *\n         * @param object the object to copy\n         * @returns the copied object\n         */\n        const handleCopy = (object, cache) => {\n            if (!object || typeof object !== 'object' || cache.has(object)) {\n                return object;\n            }\n            // DOM objects\n            if (typeof HTMLElement !== 'undefined' && object instanceof HTMLElement) {\n                return object.cloneNode(false);\n            }\n            const Constructor = object.constructor;\n            // plain objects\n            if (Constructor === realm.Object) {\n                cache.add(object);\n                return getObjectClone(object, realm, handleCopy, cache);\n            }\n            let clone;\n            // arrays\n            if (isArray(object)) {\n                cache.add(object);\n                // if strict, include non-standard properties\n                if (isStrict) {\n                    return getObjectCloneStrict(object, realm, handleCopy, cache);\n                }\n                clone = new Constructor();\n                for (let index = 0; index < object.length; index++) {\n                    clone[index] = handleCopy(object[index], cache);\n                }\n                return clone;\n            }\n            // dates\n            if (object instanceof realm.Date) {\n                return new Constructor(object.getTime());\n            }\n            // regexps\n            if (object instanceof realm.RegExp) {\n                clone = new Constructor(object.source, object.flags || getRegExpFlags(object));\n                clone.lastIndex = object.lastIndex;\n                return clone;\n            }\n            // maps\n            if (realm.Map && object instanceof realm.Map) {\n                cache.add(object);\n                clone = new Constructor();\n                object.forEach((value, key) => {\n                    clone.set(key, handleCopy(value, cache));\n                });\n                return clone;\n            }\n            // sets\n            if (realm.Set && object instanceof realm.Set) {\n                cache.add(object);\n                clone = new Constructor();\n                object.forEach((value) => {\n                    clone.add(handleCopy(value, cache));\n                });\n                return clone;\n            }\n            // buffers (node-only)\n            if (realm.Buffer && realm.Buffer.isBuffer(object)) {\n                clone = realm.Buffer.allocUnsafe\n                    ? realm.Buffer.allocUnsafe(object.length)\n                    : new Constructor(object.length);\n                object.copy(clone);\n                return clone;\n            }\n            // arraybuffers / dataviews\n            if (realm.ArrayBuffer) {\n                // dataviews\n                if (realm.ArrayBuffer.isView(object)) {\n                    return new Constructor(object.buffer.slice(0));\n                }\n                // arraybuffers\n                if (object instanceof realm.ArrayBuffer) {\n                    return object.slice(0);\n                }\n            }\n            // if the object cannot / should not be cloned, don't\n            if (\n            // promise-like\n            (hasOwnProperty.call(object, 'then') && typeof object.then === 'function')\n                // errors\n                || object instanceof Error\n                // weakmaps\n                || (realm.WeakMap && object instanceof realm.WeakMap)\n                // weaksets\n                || (realm.WeakSet && object instanceof realm.WeakSet)) {\n                return object;\n            }\n            cache.add(object);\n            // assume anything left is a custom constructor\n            return getObjectClone(object, realm, handleCopy, cache);\n        };\n        return handleCopy(object, createCache());\n    }\n}\nexports.installHook = installHook;\n//# sourceMappingURL=hook.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0B2dWUtZGV2dG9vbHMvYXBwLWJhY2tlbmQtY29yZS9saWIvaG9vay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxHQUFHLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQ0FBbUMsTUFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxPQUFPO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLE9BQU87QUFDcEc7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLE9BQU87QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyx1QkFBdUI7QUFDcEU7QUFDQSx3QkFBd0IsSUFBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLElBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QyxZQUFZLGdIQUFnSDtBQUM1SCxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxrQkFBa0IsU0FBUztBQUMzQixrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMkJBQTJCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdnVlLWRldnRvb2xzL3NoZWxsLWRldi12dWUzLy4uLy4uL25vZGVfbW9kdWxlcy9AdnVlLWRldnRvb2xzL2FwcC1iYWNrZW5kLWNvcmUvbGliL2hvb2suanM/MzU3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIHRoaXMgc2NyaXB0IGlzIGluamVjdGVkIGludG8gZXZlcnkgcGFnZS5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5zdGFsbEhvb2sgPSB2b2lkIDA7XG4vKipcbiAqIEluc3RhbGwgdGhlIGhvb2sgb24gd2luZG93LCB3aGljaCBpcyBhbiBldmVudCBlbWl0dGVyLlxuICogTm90ZSBiZWNhdXNlIENocm9tZSBjb250ZW50IHNjcmlwdHMgY2Fubm90IGRpcmVjdGx5IG1vZGlmeSB0aGUgd2luZG93IG9iamVjdCxcbiAqIHdlIGFyZSBldmFsaW5nIHRoaXMgZnVuY3Rpb24gYnkgaW5zZXJ0aW5nIGEgc2NyaXB0IHRhZy4gVGhhdCdzIHdoeSB3ZSBoYXZlXG4gKiB0byBpbmxpbmUgdGhlIHdob2xlIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gaGVyZS5cbiAqXG4gKiBAcGFyYW0ge1dpbmRvd3xnbG9iYWx9IHRhcmdldFxuICovXG5mdW5jdGlvbiBpbnN0YWxsSG9vayh0YXJnZXQsIGlzSWZyYW1lID0gZmFsc2UpIHtcbiAgICBjb25zdCBkZXZ0b29sc1ZlcnNpb24gPSAnNi4wJztcbiAgICBsZXQgbGlzdGVuZXJzID0ge307XG4gICAgZnVuY3Rpb24gaW5qZWN0SWZyYW1lSG9vayhpZnJhbWUpIHtcbiAgICAgICAgaWYgKGlmcmFtZS5fX3ZkZXZ0b29sc19faW5qZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWZyYW1lLl9fdmRldnRvb2xzX19pbmplY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBpbmplY3QgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cuX19WVUVfREVWVE9PTFNfSUZSQU1FX18gPSBpZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC50ZXh0Q29udGVudCA9IGA7KCR7aW5zdGFsbEhvb2sudG9TdHJpbmcoKX0pKHdpbmRvdywgdHJ1ZSlgO1xuICAgICAgICAgICAgICAgICAgICBpZnJhbWUuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW5qZWN0KCk7XG4gICAgICAgICAgICBpZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IGluamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGlmcmFtZUNoZWNrcyA9IDA7XG4gICAgZnVuY3Rpb24gaW5qZWN0VG9JZnJhbWVzKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZnJhbWVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaWZyYW1lOm5vdChbZGF0YS12dWUtZGV2dG9vbHMtaWdub3JlXSknKTtcbiAgICAgICAgZm9yIChjb25zdCBpZnJhbWUgb2YgaWZyYW1lcykge1xuICAgICAgICAgICAgaW5qZWN0SWZyYW1lSG9vayhpZnJhbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluamVjdFRvSWZyYW1lcygpO1xuICAgIGNvbnN0IGlmcmFtZVRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpbmplY3RUb0lmcmFtZXMoKTtcbiAgICAgICAgaWZyYW1lQ2hlY2tzKys7XG4gICAgICAgIGlmIChpZnJhbWVDaGVja3MgPj0gNSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpZnJhbWVUaW1lcik7XG4gICAgICAgIH1cbiAgICB9LCAxMDAwKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgJ19fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18nKSkge1xuICAgICAgICBpZiAodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uZGV2dG9vbHNWZXJzaW9uICE9PSBkZXZ0b29sc1ZlcnNpb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEFub3RoZXIgdmVyc2lvbiBvZiBWdWUgRGV2dG9vbHMgc2VlbXMgdG8gYmUgaW5zdGFsbGVkLiBQbGVhc2UgZW5hYmxlIG9ubHkgb25lIHZlcnNpb24gYXQgYSB0aW1lLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGhvb2s7XG4gICAgaWYgKGlzSWZyYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbmRUb1BhcmVudCA9IChjYikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBob29rID0gd2luZG93LnBhcmVudC5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICAgICAgICAgICAgICAgIGlmIChob29rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihob29rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW1Z1ZSBEZXZ0b29sc10gTm8gaG9vayBpbiBwYXJlbnQgd2luZG93Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tWdWUgRGV2dG9vbHNdIEZhaWxlZCB0byBzZW5kIG1lc3NhZ2UgdG8gcGFyZW50IHdpbmRvdycsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBob29rID0ge1xuICAgICAgICAgICAgZGV2dG9vbHNWZXJzaW9uLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFjY2Vzc29yLXBhaXJzXG4gICAgICAgICAgICBzZXQgVnVlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2VuZFRvUGFyZW50KChob29rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhvb2suVnVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFjY2Vzc29yLXBhaXJzXG4gICAgICAgICAgICBzZXQgZW5hYmxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHNlbmRUb1BhcmVudCgoaG9vaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBob29rLmVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbihldmVudCwgZm4pIHtcbiAgICAgICAgICAgICAgICBzZW5kVG9QYXJlbnQoaG9vayA9PiBob29rLm9uKGV2ZW50LCBmbikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uY2UoZXZlbnQsIGZuKSB7XG4gICAgICAgICAgICAgICAgc2VuZFRvUGFyZW50KGhvb2sgPT4gaG9vay5vbmNlKGV2ZW50LCBmbikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9mZihldmVudCwgZm4pIHtcbiAgICAgICAgICAgICAgICBzZW5kVG9QYXJlbnQoaG9vayA9PiBob29rLm9mZihldmVudCwgZm4pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgc2VuZFRvUGFyZW50KGhvb2sgPT4gaG9vay5lbWl0KGV2ZW50LCAuLi5hcmdzKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYW51cEJ1ZmZlcihtYXRjaEFyZykge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gc2VuZFRvUGFyZW50KGhvb2sgPT4gaG9vay5jbGVhbnVwQnVmZmVyKG1hdGNoQXJnKSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhvb2sgPSB7XG4gICAgICAgICAgICBkZXZ0b29sc1ZlcnNpb24sXG4gICAgICAgICAgICBWdWU6IG51bGwsXG4gICAgICAgICAgICBlbmFibGVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfYnVmZmVyOiBbXSxcbiAgICAgICAgICAgIF9idWZmZXJNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIF9idWZmZXJUb1JlbW92ZTogbmV3IE1hcCgpLFxuICAgICAgICAgICAgc3RvcmU6IG51bGwsXG4gICAgICAgICAgICBpbml0aWFsU3RhdGU6IG51bGwsXG4gICAgICAgICAgICBzdG9yZU1vZHVsZXM6IG51bGwsXG4gICAgICAgICAgICBmbHVzaFN0b3JlTW9kdWxlczogbnVsbCxcbiAgICAgICAgICAgIGFwcHM6IFtdLFxuICAgICAgICAgICAgX3JlcGxheUJ1ZmZlcihldmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2J1ZmZlcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJUb1JlbW92ZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYnVmZmVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxBcmdzID0gYnVmZmVyW2ldLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICBhbGxBcmdzWzBdID09PSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFsbEFyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2J1ZmZlci5wdXNoKGJ1ZmZlcltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uKGV2ZW50LCBmbikge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRldmVudCA9IGAkJHtldmVudH1gO1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbJGV2ZW50XSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbJGV2ZW50XS5wdXNoKGZuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1skZXZlbnRdID0gW2ZuXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwbGF5QnVmZmVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jZShldmVudCwgZm4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvZmYoZXZlbnQsIGZuKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBgJCR7ZXZlbnR9YDtcbiAgICAgICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYnMgPSBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2IgPSBjYnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRldmVudCA9IGAkJHtldmVudH1gO1xuICAgICAgICAgICAgICAgIGxldCBjYnMgPSBsaXN0ZW5lcnNbJGV2ZW50XTtcbiAgICAgICAgICAgICAgICBpZiAoY2JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNicyA9IGNicy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2JzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5jYXRjaCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbSG9va10gRXJyb3IgaW4gYXN5bmMgZXZlbnQgaGFuZGxlciBmb3IgJHtldmVudH0gd2l0aCBhcmdzOmAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbSG9va10gRXJyb3IgaW4gZXZlbnQgaGFuZGxlciBmb3IgJHtldmVudH0gd2l0aCBhcmdzOmAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gW0RhdGUubm93KCksIGV2ZW50LCAuLi5hcmdzXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLnB1c2goYnVmZmVyZWQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ29iamVjdCcgJiYgYXJnc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgYnkgY29tcG9uZW50IGluc3RhbmNlICAoM3JkLCA0dGggb3IgNXRoIGFyZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJNYXAuc2V0KGFyZ3NbaV0sIGJ1ZmZlcmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZSBidWZmZXJlZCBldmVudHMgd2l0aCBhbnkgYXJndW1lbnQgdGhhdCBpcyBlcXVhbCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAgICAgICAgICAgKiBAcGFyYW0gbWF0Y2hBcmcgR2l2ZW4gdmFsdWUgdG8gbWF0Y2guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNsZWFudXBCdWZmZXIobWF0Y2hBcmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbkJ1ZmZlciA9IHRoaXMuX2J1ZmZlck1hcC5oYXMobWF0Y2hBcmcpO1xuICAgICAgICAgICAgICAgIGlmIChpbkJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIGV2ZW50IGZvciByZW1vdmFsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlclRvUmVtb3ZlLnNldCh0aGlzLl9idWZmZXJNYXAuZ2V0KG1hdGNoQXJnKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbkJ1ZmZlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfY2xlYW51cEJ1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIGJ1ZmZlciBldmVudHMgdGhhdCBhcmUgb2xkZXIgdGhhbiAxMCBzZWNvbmRzIG9yIG1hcmtlZCBmb3IgcmVtb3ZhbFxuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlciA9IHRoaXMuX2J1ZmZlci5maWx0ZXIoYXJncyA9PiAhdGhpcy5fYnVmZmVyVG9SZW1vdmUuaGFzKGFyZ3MpICYmIG5vdyAtIGFyZ3NbMF0gPCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyVG9SZW1vdmUuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXJNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGhvb2suX2NsZWFudXBCdWZmZXIoKTtcbiAgICAgICAgfSwgMTAwMDApO1xuICAgICAgICBob29rLm9uY2UoJ2luaXQnLCAoVnVlKSA9PiB7XG4gICAgICAgICAgICBob29rLlZ1ZSA9IFZ1ZTtcbiAgICAgICAgICAgIGlmIChWdWUpIHtcbiAgICAgICAgICAgICAgICBWdWUucHJvdG90eXBlLiRpbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmbiA9IHRhcmdldC5fX1ZVRV9ERVZUT09MU19JTlNQRUNUX187XG4gICAgICAgICAgICAgICAgICAgIGZuICYmIGZuKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBob29rLm9uKCdhcHA6aW5pdCcsIChhcHAsIHZlcnNpb24sIHR5cGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhcHBSZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgYXBwLFxuICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgdHlwZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaG9vay5hcHBzLnB1c2goYXBwUmVjb3JkKTtcbiAgICAgICAgICAgIGhvb2suZW1pdCgnYXBwOmFkZCcsIGFwcFJlY29yZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBob29rLm9uY2UoJ3Z1ZXg6aW5pdCcsIChzdG9yZSkgPT4ge1xuICAgICAgICAgICAgaG9vay5zdG9yZSA9IHN0b3JlO1xuICAgICAgICAgICAgaG9vay5pbml0aWFsU3RhdGUgPSBjbG9uZShzdG9yZS5zdGF0ZSk7XG4gICAgICAgICAgICBjb25zdCBvcmlnUmVwbGFjZVN0YXRlID0gc3RvcmUucmVwbGFjZVN0YXRlLmJpbmQoc3RvcmUpO1xuICAgICAgICAgICAgc3RvcmUucmVwbGFjZVN0YXRlID0gKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgaG9vay5pbml0aWFsU3RhdGUgPSBjbG9uZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgb3JpZ1JlcGxhY2VTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gRHluYW1pYyBtb2R1bGVzXG4gICAgICAgICAgICBsZXQgb3JpZ1JlZ2lzdGVyLCBvcmlnVW5yZWdpc3RlcjtcbiAgICAgICAgICAgIGlmIChzdG9yZS5yZWdpc3Rlck1vZHVsZSkge1xuICAgICAgICAgICAgICAgIGhvb2suc3RvcmVNb2R1bGVzID0gW107XG4gICAgICAgICAgICAgICAgb3JpZ1JlZ2lzdGVyID0gc3RvcmUucmVnaXN0ZXJNb2R1bGUuYmluZChzdG9yZSk7XG4gICAgICAgICAgICAgICAgc3RvcmUucmVnaXN0ZXJNb2R1bGUgPSAocGF0aCwgbW9kdWxlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBbcGF0aF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaG9vay5zdG9yZU1vZHVsZXMucHVzaCh7IHBhdGgsIG1vZHVsZSwgb3B0aW9ucyB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ1JlZ2lzdGVyKHBhdGgsIG1vZHVsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vhcmx5IHJlZ2lzdGVyIG1vZHVsZScsIHBhdGgsIG1vZHVsZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9yaWdVbnJlZ2lzdGVyID0gc3RvcmUudW5yZWdpc3Rlck1vZHVsZS5iaW5kKHN0b3JlKTtcbiAgICAgICAgICAgICAgICBzdG9yZS51bnJlZ2lzdGVyTW9kdWxlID0gKHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtwYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYXRoLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBob29rLnN0b3JlTW9kdWxlcy5maW5kSW5kZXgobSA9PiBtLnBhdGguam9pbignLycpID09PSBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rLnN0b3JlTW9kdWxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9yaWdVbnJlZ2lzdGVyKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlYXJseSB1bnJlZ2lzdGVyIG1vZHVsZScsIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvb2suZmx1c2hTdG9yZU1vZHVsZXMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcmUucmVwbGFjZVN0YXRlID0gb3JpZ1JlcGxhY2VTdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmUucmVnaXN0ZXJNb2R1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucmVnaXN0ZXJNb2R1bGUgPSBvcmlnUmVnaXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnVucmVnaXN0ZXJNb2R1bGUgPSBvcmlnVW5yZWdpc3RlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvb2suc3RvcmVNb2R1bGVzIHx8IFtdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fJywge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9vaztcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBIYW5kbGUgYXBwcyBpbml0aWFsaXplZCBiZWZvcmUgaG9vayBpbmplY3Rpb25cbiAgICBpZiAodGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhcmdldC5fX1ZVRV9ERVZUT09MU19IT09LX1JFUExBWV9fLmZvckVhY2goY2IgPT4gY2IoaG9vaykpO1xuICAgICAgICAgICAgdGFyZ2V0Ll9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW3Z1ZS1kZXZ0b29sc10gRXJyb3IgZHVyaW5nIGhvb2sgcmVwbGF5JywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2xvbmUgZGVlcCB1dGlsaXR5IGZvciBjbG9uaW5nIGluaXRpYWwgc3RhdGUgb2YgdGhlIHN0b3JlXG4gICAgLy8gRm9ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3BsYW50dGhlaWRlYS9mYXN0LWNvcHlcbiAgICAvLyBMYXN0IHVwZGF0ZTogMjAxOS0xMC0zMFxuICAgIC8vIOKaoO+4jyBEb24ndCBmb3JnZXQgdG8gdXBkYXRlIGAuL2hvb2suanNgXG4gICAgLy8gdXRpbHNcbiAgICBjb25zdCB7IHRvU3RyaW5nOiB0b1N0cmluZ0Z1bmN0aW9uIH0gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgY29uc3QgeyBjcmVhdGUsIGRlZmluZVByb3BlcnR5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIGdldE93blByb3BlcnR5TmFtZXMsIGdldE93blByb3BlcnR5U3ltYm9scywgZ2V0UHJvdG90eXBlT2YsIH0gPSBPYmplY3Q7XG4gICAgY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSwgcHJvcGVydHlJc0VudW1lcmFibGUgfSA9IE9iamVjdC5wcm90b3R5cGU7XG4gICAgLyoqXG4gICAgICogQGVudW1cbiAgICAgKlxuICAgICAqIEBjb25zdCB7b2JqZWN0fSBTVVBQT1JUU1xuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBTWU1CT0xfUFJPUEVSVElFUyBhcmUgc3ltYm9sIHByb3BlcnRpZXMgc3VwcG9ydGVkXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBXRUFLU0VUIGlzIFdlYWtTZXQgc3VwcG9ydGVkXG4gICAgICovXG4gICAgY29uc3QgU1VQUE9SVFMgPSB7XG4gICAgICAgIFNZTUJPTF9QUk9QRVJUSUVTOiB0eXBlb2YgZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSAnZnVuY3Rpb24nLFxuICAgICAgICBXRUFLU0VUOiB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBjcmVhdGVDYWNoZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogZ2V0IGEgbmV3IGNhY2hlIG9iamVjdCB0byBwcmV2ZW50IGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBuZXcgY2FjaGUgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3QgY3JlYXRlQ2FjaGUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChTVVBQT1JUUy5XRUFLU0VUKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYWtTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmplY3QgPSBjcmVhdGUoe1xuICAgICAgICAgICAgYWRkOiB2YWx1ZSA9PiBvYmplY3QuX3ZhbHVlcy5wdXNoKHZhbHVlKSxcbiAgICAgICAgICAgIGhhczogdmFsdWUgPT4gISF+b2JqZWN0Ll92YWx1ZXMuaW5kZXhPZih2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgICAgICBvYmplY3QuX3ZhbHVlcyA9IFtdO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGdldENsZWFuQ2xvbmVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIGdldCBhbiBlbXB0eSB2ZXJzaW9uIG9mIHRoZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm90b3R5cGUgaXQgaGFzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gYnVpbGQgYSBjbGVhbiBjbG9uZSBmcm9tXG4gICAgICogQHBhcmFtIHJlYWxtIHRoZSByZWFsbSB0aGUgb2JqZWN0IHJlc2lkZXMgaW5cbiAgICAgKiBAcmV0dXJucyB0aGUgZW1wdHkgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNvbnN0IGdldENsZWFuQ2xvbmUgPSAob2JqZWN0LCByZWFsbSkgPT4ge1xuICAgICAgICBpZiAoIW9iamVjdC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG8sIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgICBjb25zdCBwcm90b3R5cGUgPSBvYmplY3QuX19wcm90b19fIHx8IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgICAgIGlmIChvYmplY3QuY29uc3RydWN0b3IgPT09IHJlYWxtLk9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvdHlwZSA9PT0gcmVhbG0uT2JqZWN0LnByb3RvdHlwZSA/IHt9IDogY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKH50b1N0cmluZ0Z1bmN0aW9uLmNhbGwob2JqZWN0LmNvbnN0cnVjdG9yKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBvYmplY3QuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gRXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gZ2V0T2JqZWN0Q2xvbmVMb29zZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogZ2V0IGEgY29weSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIGxvb3NlIHJ1bGVzLCBtZWFuaW5nIGFsbCBlbnVtZXJhYmxlIGtleXNcbiAgICAgKiBhbmQgc3ltYm9scyBhcmUgY29waWVkLCBidXQgcHJvcGVydHkgZGVzY3JpcHRvcnMgYXJlIG5vdCBjb25zaWRlcmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY2xvbmVcbiAgICAgKiBAcGFyYW0gcmVhbG0gdGhlIHJlYWxtIHRoZSBvYmplY3QgcmVzaWRlcyBpblxuICAgICAqIEBwYXJhbSBoYW5kbGVDb3B5IHRoZSBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgY29weWluZyB0aGUgb2JqZWN0XG4gICAgICogQHJldHVybnMgdGhlIGNvcGllZCBvYmplY3RcbiAgICAgKi9cbiAgICBjb25zdCBnZXRPYmplY3RDbG9uZUxvb3NlID0gKG9iamVjdCwgcmVhbG0sIGhhbmRsZUNvcHksIGNhY2hlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb25lID0gZ2V0Q2xlYW5DbG9uZShvYmplY3QsIHJlYWxtKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZVtrZXldID0gaGFuZGxlQ29weShvYmplY3Rba2V5XSwgY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChTVVBQT1JUUy5TWU1CT0xfUFJPUEVSVElFUykge1xuICAgICAgICAgICAgY29uc3Qgc3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgICAgICAgaWYgKHN5bWJvbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBzeW1ib2w7IGluZGV4IDwgc3ltYm9scy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVbc3ltYm9sXSA9IGhhbmRsZUNvcHkob2JqZWN0W3N5bWJvbF0sIGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gZ2V0T2JqZWN0Q2xvbmVTdHJpY3RcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIGdldCBhIGNvcHkgb2YgdGhlIG9iamVjdCBiYXNlZCBvbiBzdHJpY3QgcnVsZXMsIG1lYW5pbmcgYWxsIGtleXMgYW5kIHN5bWJvbHNcbiAgICAgKiBhcmUgY29waWVkIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZXNjcmlwdG9yc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9iamVjdCB0aGUgb2JqZWN0IHRvIGNsb25lXG4gICAgICogQHBhcmFtIHJlYWxtIHRoZSByZWFsbSB0aGUgb2JqZWN0IHJlc2lkZXMgaW5cbiAgICAgKiBAcGFyYW0gaGFuZGxlQ29weSB0aGUgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIGNvcHlpbmcgdGhlIG9iamVjdFxuICAgICAqIEByZXR1cm5zIHRoZSBjb3BpZWQgb2JqZWN0XG4gICAgICovXG4gICAgY29uc3QgZ2V0T2JqZWN0Q2xvbmVTdHJpY3QgPSAob2JqZWN0LCByZWFsbSwgaGFuZGxlQ29weSwgY2FjaGUpID0+IHtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBnZXRDbGVhbkNsb25lKG9iamVjdCwgcmVhbG0pO1xuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gU1VQUE9SVFMuU1lNQk9MX1BST1BFUlRJRVNcbiAgICAgICAgICAgID8gW10uY29uY2F0KGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkpXG4gICAgICAgICAgICA6IGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDAsIHByb3BlcnR5LCBkZXNjcmlwdG9yOyBpbmRleCA8IHByb3BlcnRpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHkgIT09ICdjYWxsZWUnICYmIHByb3BlcnR5ICE9PSAnY2FsbGVyJykge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gaGFuZGxlQ29weShvYmplY3RbcHJvcGVydHldLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KGNsb25lLCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvbiBnZXRSZWdFeHBGbGFnc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogZ2V0IHRoZSBmbGFncyB0byBhcHBseSB0byB0aGUgY29waWVkIHJlZ2V4cFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZ0V4cCB0aGUgcmVnZXhwIHRvIGdldCB0aGUgZmxhZ3Mgb2ZcbiAgICAgKiBAcmV0dXJucyB0aGUgZmxhZ3MgZm9yIHRoZSByZWdleHBcbiAgICAgKi9cbiAgICBjb25zdCBnZXRSZWdFeHBGbGFncyA9IChyZWdFeHApID0+IHtcbiAgICAgICAgbGV0IGZsYWdzID0gJyc7XG4gICAgICAgIGlmIChyZWdFeHAuZ2xvYmFsKSB7XG4gICAgICAgICAgICBmbGFncyArPSAnZyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ0V4cC5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICBmbGFncyArPSAnaSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZ0V4cC5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgIGZsYWdzICs9ICdtJztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVnRXhwLnVuaWNvZGUpIHtcbiAgICAgICAgICAgIGZsYWdzICs9ICd1JztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVnRXhwLnN0aWNreSkge1xuICAgICAgICAgICAgZmxhZ3MgKz0gJ3knO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICB9O1xuICAgIGNvbnN0IHsgaXNBcnJheSB9ID0gQXJyYXk7XG4gICAgY29uc3QgR0xPQkFMX1RISVMgPSAoKCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QsIHJldHVybmluZyBcInRoaXNcIi4nKTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIGNsb25lXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBjb3B5IGFuIG9iamVjdCBkZWVwbHkgYXMgbXVjaCBhcyBwb3NzaWJsZVxuICAgICAqXG4gICAgICogSWYgYHN0cmljdGAgaXMgYXBwbGllZCwgdGhlbiBhbGwgcHJvcGVydGllcyAoaW5jbHVkaW5nIG5vbi1lbnVtZXJhYmxlIG9uZXMpXG4gICAgICogYXJlIGNvcGllZCB3aXRoIHRoZWlyIG9yaWdpbmFsIHByb3BlcnR5IGRlc2NyaXB0b3JzIG9uIGJvdGggb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAqXG4gICAgICogVGhlIG9iamVjdCBpcyBjb21wYXJlZCB0byB0aGUgZ2xvYmFsIGNvbnN0cnVjdG9ycyBpbiB0aGUgYHJlYWxtYCBwcm92aWRlZCxcbiAgICAgKiBhbmQgdGhlIG5hdGl2ZSBjb25zdHJ1Y3RvciBpcyBhbHdheXMgdXNlZCB0byBlbnN1cmUgdGhhdCBleHRlbnNpb25zIG9mIG5hdGl2ZVxuICAgICAqIG9iamVjdHMgKGFsbG93cyBpbiBFUzIwMTUrKSBhcmUgbWFpbnRhaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvYmplY3QgdGhlIG9iamVjdCB0byBjb3B5XG4gICAgICogQHBhcmFtIFtvcHRpb25zXSB0aGUgb3B0aW9ucyBmb3IgY29weWluZyB3aXRoXG4gICAgICogQHBhcmFtIFtvcHRpb25zLmlzU3RyaWN0XSBzaG91bGQgdGhlIGNvcHkgYmUgc3RyaWN0XG4gICAgICogQHBhcmFtIFtvcHRpb25zLnJlYWxtXSB0aGUgcmVhbG0gKHRoaXMpIG9iamVjdCB0aGUgb2JqZWN0IGlzIGNvcGllZCBmcm9tXG4gICAgICogQHJldHVybnMgdGhlIGNvcGllZCBvYmplY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZShvYmplY3QsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIC8vIG1hbnVhbGx5IGNvYWxlc2NlZCBpbnN0ZWFkIG9mIGRlZmF1bHQgcGFyYW1ldGVycyBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgY29uc3QgaXNTdHJpY3QgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuaXNTdHJpY3QpO1xuICAgICAgICBjb25zdCByZWFsbSA9IChvcHRpb25zICYmIG9wdGlvbnMucmVhbG0pIHx8IEdMT0JBTF9USElTO1xuICAgICAgICBjb25zdCBnZXRPYmplY3RDbG9uZSA9IGlzU3RyaWN0XG4gICAgICAgICAgICA/IGdldE9iamVjdENsb25lU3RyaWN0XG4gICAgICAgICAgICA6IGdldE9iamVjdENsb25lTG9vc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZnVuY3Rpb24gaGFuZGxlQ29weVxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogY29weSB0aGUgb2JqZWN0IHJlY3Vyc2l2ZWx5IGJhc2VkIG9uIGl0cyB0eXBlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvYmplY3QgdGhlIG9iamVjdCB0byBjb3B5XG4gICAgICAgICAqIEByZXR1cm5zIHRoZSBjb3BpZWQgb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBoYW5kbGVDb3B5ID0gKG9iamVjdCwgY2FjaGUpID0+IHtcbiAgICAgICAgICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnIHx8IGNhY2hlLmhhcyhvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERPTSBvYmplY3RzXG4gICAgICAgICAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IENvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gcGxhaW4gb2JqZWN0c1xuICAgICAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSByZWFsbS5PYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5hZGQob2JqZWN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T2JqZWN0Q2xvbmUob2JqZWN0LCByZWFsbSwgaGFuZGxlQ29weSwgY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNsb25lO1xuICAgICAgICAgICAgLy8gYXJyYXlzXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGUuYWRkKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgc3RyaWN0LCBpbmNsdWRlIG5vbi1zdGFuZGFyZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRPYmplY3RDbG9uZVN0cmljdChvYmplY3QsIHJlYWxtLCBoYW5kbGVDb3B5LCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsb25lID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG9iamVjdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVbaW5kZXhdID0gaGFuZGxlQ29weShvYmplY3RbaW5kZXhdLCBjYWNoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRhdGVzXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgcmVhbG0uRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3Iob2JqZWN0LmdldFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWdleHBzXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgcmVhbG0uUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBuZXcgQ29uc3RydWN0b3Iob2JqZWN0LnNvdXJjZSwgb2JqZWN0LmZsYWdzIHx8IGdldFJlZ0V4cEZsYWdzKG9iamVjdCkpO1xuICAgICAgICAgICAgICAgIGNsb25lLmxhc3RJbmRleCA9IG9iamVjdC5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFwc1xuICAgICAgICAgICAgaWYgKHJlYWxtLk1hcCAmJiBvYmplY3QgaW5zdGFuY2VvZiByZWFsbS5NYXApIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5hZGQob2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgICAgIG9iamVjdC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLnNldChrZXksIGhhbmRsZUNvcHkodmFsdWUsIGNhY2hlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0c1xuICAgICAgICAgICAgaWYgKHJlYWxtLlNldCAmJiBvYmplY3QgaW5zdGFuY2VvZiByZWFsbS5TZXQpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5hZGQob2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgICAgICAgICAgIG9iamVjdC5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbG9uZS5hZGQoaGFuZGxlQ29weSh2YWx1ZSwgY2FjaGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBidWZmZXJzIChub2RlLW9ubHkpXG4gICAgICAgICAgICBpZiAocmVhbG0uQnVmZmVyICYmIHJlYWxtLkJ1ZmZlci5pc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSByZWFsbS5CdWZmZXIuYWxsb2NVbnNhZmVcbiAgICAgICAgICAgICAgICAgICAgPyByZWFsbS5CdWZmZXIuYWxsb2NVbnNhZmUob2JqZWN0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgQ29uc3RydWN0b3Iob2JqZWN0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmNvcHkoY2xvbmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFycmF5YnVmZmVycyAvIGRhdGF2aWV3c1xuICAgICAgICAgICAgaWYgKHJlYWxtLkFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gZGF0YXZpZXdzXG4gICAgICAgICAgICAgICAgaWYgKHJlYWxtLkFycmF5QnVmZmVyLmlzVmlldyhvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3Iob2JqZWN0LmJ1ZmZlci5zbGljZSgwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFycmF5YnVmZmVyc1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiByZWFsbS5BcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0LnNsaWNlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZSBvYmplY3QgY2Fubm90IC8gc2hvdWxkIG5vdCBiZSBjbG9uZWQsIGRvbid0XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBwcm9taXNlLWxpa2VcbiAgICAgICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ3RoZW4nKSAmJiB0eXBlb2Ygb2JqZWN0LnRoZW4gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgLy8gZXJyb3JzXG4gICAgICAgICAgICAgICAgfHwgb2JqZWN0IGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICAvLyB3ZWFrbWFwc1xuICAgICAgICAgICAgICAgIHx8IChyZWFsbS5XZWFrTWFwICYmIG9iamVjdCBpbnN0YW5jZW9mIHJlYWxtLldlYWtNYXApXG4gICAgICAgICAgICAgICAgLy8gd2Vha3NldHNcbiAgICAgICAgICAgICAgICB8fCAocmVhbG0uV2Vha1NldCAmJiBvYmplY3QgaW5zdGFuY2VvZiByZWFsbS5XZWFrU2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWNoZS5hZGQob2JqZWN0KTtcbiAgICAgICAgICAgIC8vIGFzc3VtZSBhbnl0aGluZyBsZWZ0IGlzIGEgY3VzdG9tIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICByZXR1cm4gZ2V0T2JqZWN0Q2xvbmUob2JqZWN0LCByZWFsbSwgaGFuZGxlQ29weSwgY2FjaGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaGFuZGxlQ29weShvYmplY3QsIGNyZWF0ZUNhY2hlKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuaW5zdGFsbEhvb2sgPSBpbnN0YWxsSG9vaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2suanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@vue-devtools/app-backend-core/lib/hook.js\n");

/***/ }),

/***/ "../shell-host/src/hook.js":
/*!*********************************!*\
  !*** ../shell-host/src/hook.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _back_hook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @back/hook */ \"../../node_modules/@vue-devtools/app-backend-core/lib/hook.js\");\n\n(0,_back_hook__WEBPACK_IMPORTED_MODULE_0__.installHook)(window);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc2hlbGwtaG9zdC9zcmMvaG9vay5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBRUFBLHVEQUFXLENBQUNDLE1BQUQsQ0FBWCIsInNvdXJjZXMiOlsid2VicGFjazovL0B2dWUtZGV2dG9vbHMvc2hlbGwtZGV2LXZ1ZTMvLi4vc2hlbGwtaG9zdC9zcmMvaG9vay5qcz8wZGQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluc3RhbGxIb29rIH0gZnJvbSAnQGJhY2svaG9vaydcblxuaW5zdGFsbEhvb2sod2luZG93KVxuIl0sIm5hbWVzIjpbImluc3RhbGxIb29rIiwid2luZG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../shell-host/src/hook.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("../shell-host/src/hook.js");
/******/ 	
/******/ })()
;